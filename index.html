<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Junho Coloring Book</title>
  <style>
    :root { --bg:#f6f6f6; --card:#fff; --line:#ddd; --r:14px; }
    body { margin:0; background:var(--bg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    .wrap { max-width: 900px; margin: 0 auto; padding: 14px; }
    h1 { font-size: 18px; margin: 4px 0 10px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .card { background:var(--card); border:1px solid var(--line); border-radius: var(--r); padding:10px; }
    .thumbs { display:flex; gap:8px; overflow:auto; padding:6px; }
    .thumbs img { height:64px; width:auto; border-radius:10px; border:2px solid transparent; cursor:pointer; background:#fff; }
    .thumbs img.active { border-color:#111; }
    .controls { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    label { display:flex; gap:8px; align-items:center; }
    button { cursor:pointer; border:1px solid var(--line); background:#fff; border-radius:12px; padding:10px 12px; }
    button:active { transform: translateY(1px); }
    .small { font-size:12px; color:#666; }
    #stage { background:#fff; border:1px solid var(--line); border-radius:16px; overflow:hidden; touch-action:none; }
    canvas { display:block; width:100%; height:auto; }
    .hint { font-size:12px; color:#444; margin-top:10px; line-height:1.45; }
    .pill { padding:6px 10px; border-radius:999px; border:1px solid var(--line); background:#fff; }
    .spacer { flex: 1 1 auto; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>ğŸ¨ Junho Coloring Book (ë²„í‚· ì±„ìš°ê¸° + ì„  ìœ ì§€ + í™•ëŒ€/ì´ë™)</h1>

  <!-- âœ… ì•± ë‚´ ê°¤ëŸ¬ë¦¬ -->
  <div class="card">
    <div class="row">
      <div class="pill">ğŸ“š í˜ì´ì§€ ì„ íƒ</div>
      <div class="spacer"></div>
      <!-- ê¸°ì¡´ ì¢‹ì€ ê¸°ëŠ¥ ìœ ì§€: (ì„ íƒì‚¬í•­) íŒŒì¼ ì—…ë¡œë“œë„ ë‚¨ê²¨ë‘  -->
      <label class="small" title="ì›í•˜ë©´ ë‚´ ì‚¬ì§„/ë„ì•ˆë„ ì—…ë¡œë“œí•´ì„œ ì¹ í•  ìˆ˜ ìˆì–´ìš”.">
        (ì˜µì…˜) ë‚´ ë„ì•ˆ ì—…ë¡œë“œ
        <input id="file" type="file" accept="image/*" />
      </label>
    </div>
    <div id="thumbs" class="thumbs"></div>
  </div>

  <!-- âœ… ì»¨íŠ¸ë¡¤ -->
  <div class="card controls" style="margin-top:12px;">
    <label>ìƒ‰ <input id="color" type="color" value="#ff4d6d" /></label>

    <label class="small">
      ì„  ë¯¼ê°ë„(ë‚®ì„ìˆ˜ë¡ ê²€ì€ ì„ ë§Œ ë²½ìœ¼ë¡œ)
      <input id="threshold" type="range" min="30" max="220" value="95" />
      <span id="thv">95</span>
    </label>

    <button id="undo">ë˜ëŒë¦¬ê¸°</button>
    <button id="clear">ì¹ í•œ ê²ƒë§Œ ì§€ìš°ê¸°</button>
    <button id="auto">ìë™ìœ¼ë¡œ ì—¬ëŸ¬ ì¹¸ ì±„ìš°ê¸°</button>

    <span class="spacer"></span>

    <!-- âœ… í™•ëŒ€/ì´ë™(ë‹ë³´ê¸° ëŠë‚Œ) -->
    <button id="zoomIn">ï¼‹ í™•ëŒ€</button>
    <button id="zoomOut">ï¼ ì¶•ì†Œ</button>
    <button id="zoomReset">ì›ë˜ëŒ€ë¡œ</button>
    <button id="save">PNG ì €ì¥</button>
  </div>

  <div id="stage" style="margin-top:12px;">
    <canvas id="view"></canvas>
  </div>

  <div class="hint">
    âœ… ì‚¬ìš©ë²•: í˜ì´ì§€ ì„ íƒ â†’ ìƒ‰ ì„ íƒ â†’ í™”ë©´ì„ í†¡ ëˆ„ë¥´ë©´ ê·¸ ì˜ì—­ë§Œ ì±„ì›Œì ¸ìš”.<br/>
    âœ… í™•ëŒ€/ì´ë™: ë‘ ì†ê°€ë½ í•€ì¹˜ í™•ëŒ€/ì¶•ì†Œ + í•œ ì†ê°€ë½ ë“œë˜ê·¸ë¡œ ì´ë™(ëª¨ë°”ì¼).<br/>
    âœ… ì¤‘ìš”í•œ ì : ìƒ‰ì¹ í•´ë„ <b>ê²€ì • ìœ¤ê³½ì„ ì´ í•­ìƒ ë§¨ ìœ„ì— ë‹¤ì‹œ ê·¸ë ¤ì ¸</b> ë˜ë ·í•˜ê²Œ ìœ ì§€ë©ë‹ˆë‹¤.
  </div>
</div>

<script>
(() => {
  // âœ… ì—¬ê¸°ì— í˜ì´ì§€ ì¶”ê°€ë§Œ í•˜ë©´ ì—…ë°ì´íŠ¸ ë!
  // repoì— /pages/page1.png ì´ëŸ° ì‹ìœ¼ë¡œ ì˜¬ë ¤ë‘ë©´ ë¨
  const PAGES = [
    { title: "Page 1", url: "page1.png" },
    { title: "Page 2", url: "page2.png" },
    { title: "Page 3", url: "page3.png" },
  ];

  const view = document.getElementById('view');
  const vctx = view.getContext('2d');

  const file = document.getElementById('file');
  const colorInp = document.getElementById('color');
  const thresholdInp = document.getElementById('threshold');
  const thv = document.getElementById('thv');

  const undoBtn = document.getElementById('undo');
  const clearBtn = document.getElementById('clear');
  const autoBtn = document.getElementById('auto');

  const zoomInBtn = document.getElementById('zoomIn');
  const zoomOutBtn = document.getElementById('zoomOut');
  const zoomResetBtn = document.getElementById('zoomReset');
  const saveBtn = document.getElementById('save');

  const thumbsEl = document.getElementById('thumbs');
  const stage = document.getElementById('stage');

  thv.textContent = thresholdInp.value;

  // ---- offscreen layers ----
  const baseC = document.createElement('canvas'); const baseX = baseC.getContext('2d', { willReadFrequently:true });
  const paintC = document.createElement('canvas'); const paintX = paintC.getContext('2d', { willReadFrequently:true });
  const lineC = document.createElement('canvas'); const lineX = lineC.getContext('2d', { willReadFrequently:true });
  const compC = document.createElement('canvas'); const compX = compC.getContext('2d'); // í•©ì„± ê²°ê³¼(ë Œë”ìš©)

  let baseImageData = null;
  let paintImageData = null;
  let lineMaskData = null;
  let history = [];

  // ---- zoom/pan state ----
  let scale = 1;
  let offsetX = 0;
  let offsetY = 0;
  let isPanning = false;
  let lastPan = {x:0,y:0};

  // pinch
  let pinchOn = false;
  let pinchStartDist = 0;
  let pinchStartScale = 1;
  let pinchMid = {x:0,y:0};

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function fitToScreen() {
    // ì´ë¯¸ì§€ ì „ì²´ê°€ í™”ë©´ì— ë“¤ì–´ì˜¤ë„ë¡ scale/offset ì´ˆê¸°í™”
    if (!compC.width || !compC.height) return;
    const rect = view.getBoundingClientRect();
    const sx = rect.width / compC.width;
    const sy = rect.height / compC.height;
    scale = Math.min(sx, sy);
    offsetX = (rect.width - compC.width * scale) / 2;
    offsetY = (rect.height - compC.height * scale) / 2;
    scale = clamp(scale, 0.2, 6);
  }

  function resizeViewCanvasToCSS() {
    const rect = stage.getBoundingClientRect();
    // ê³ í•´ìƒë„(ë ˆí‹°ë‚˜) ëŒ€ì‘
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    view.width = Math.floor(rect.width * dpr);
    // ë†’ì´ëŠ” ì´ë¯¸ì§€ ë¹„ìœ¨ì— ë§ì¶°
    const ar = compC.width && compC.height ? (compC.height / compC.width) : (2/3);
    view.height = Math.floor(rect.width * ar * dpr);
    view.style.width = rect.width + 'px';
    view.style.height = (rect.width * ar) + 'px';
    vctx.setTransform(dpr,0,0,dpr,0,0); // ì´í›„ drawì—ì„œëŠ” CSS px ê¸°ì¤€ìœ¼ë¡œ ê·¸ë¦¼
    // (dpr transformì´ ìˆìœ¼ë©´, renderì—ì„œ ì¢Œí‘œëŠ” CSS pxë¡œ ì“°ë©´ ë¨)
  }

  window.addEventListener('resize', () => {
    resizeViewCanvasToCSS();
    fitToScreen();
    render();
  });

  // ---- util: color ----
  function getRgb(hex) {
    const h = hex.replace('#','');
    return {
      r: parseInt(h.slice(0,2),16),
      g: parseInt(h.slice(2,4),16),
      b: parseInt(h.slice(4,6),16)
    };
  }

  function pushHistory() {
    if (!paintImageData) return;
    history.push(new ImageData(new Uint8ClampedArray(paintImageData.data), paintImageData.width, paintImageData.height));
    if (history.length > 25) history.shift();
  }

  function rebuildLineMask() {
    if (!baseImageData) return;
    const w = baseImageData.width, h = baseImageData.height;
    const thr = parseInt(thresholdInp.value, 10);

    lineMaskData = new ImageData(w, h);
    const bd = baseImageData.data;
    const ld = lineMaskData.data;

    for (let i = 0; i < bd.length; i += 4) {
      const r = bd[i], g = bd[i+1], b = bd[i+2];
      const lum = r*0.299 + g*0.587 + b*0.114;

      if (lum < thr) {
        ld[i]=0; ld[i+1]=0; ld[i+2]=0; ld[i+3]=255; // ì„ ì€ ê²€ì •
      } else {
        ld[i+3]=0; // íˆ¬ëª…
      }
    }
  }

  function composite() {
    if (!baseImageData) return;

    // base
    baseX.putImageData(baseImageData, 0, 0);

    // paint (ì´ë¯¸ì§€ë°ì´í„° â†’ ìº”ë²„ìŠ¤)
    if (paintImageData) paintX.putImageData(paintImageData, 0, 0);

    // line
    if (lineMaskData) lineX.putImageData(lineMaskData, 0, 0);

    // í•©ì„± (base â†’ paint â†’ line) : ì„ ì´ ë§¨ ìœ„ë¼ ë˜ë ·í•¨
    compX.clearRect(0,0,compC.width, compC.height);
    compX.drawImage(baseC, 0, 0);
    compX.drawImage(paintC, 0, 0);
    compX.drawImage(lineC, 0, 0);
  }

  function render() {
    if (!compC.width || !compC.height) {
      vctx.clearRect(0,0,view.width,view.height);
      return;
    }
    // vctxëŠ” dpr transformì´ ì´ë¯¸ ì ìš©ë˜ì–´ ìˆì–´ â€œCSS px ì¢Œí‘œâ€ë¡œ ê·¸ë¦¬ë©´ ë¨
    const rect = view.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;

    vctx.clearRect(0,0,w,h);

    // draw with zoom/pan
    vctx.save();
    vctx.translate(offsetX, offsetY);
    vctx.scale(scale, scale);
    vctx.drawImage(compC, 0, 0);
    vctx.restore();
  }

  // ---- mapping view coords -> image coords ----
  function clientToCanvasCss(clientX, clientY) {
    const rect = view.getBoundingClientRect();
    return { x: clientX - rect.left, y: clientY - rect.top };
  }

  function cssToImageXY(cssX, cssY) {
    // inverse of translate/scale
    const x = (cssX - offsetX) / scale;
    const y = (cssY - offsetY) / scale;
    return { x: Math.floor(x), y: Math.floor(y) };
  }

  function isWallAt(x, y) {
    const w = baseImageData.width;
    const i = (y*w + x)*4;
    const r = baseImageData.data[i];
    const g = baseImageData.data[i+1];
    const b = baseImageData.data[i+2];
    const lum = (r*0.299 + g*0.587 + b*0.114);
    return lum < parseInt(thresholdInp.value, 10);
  }

  function bucketFill(startX, startY, fillHex) {
    if (!baseImageData || !paintImageData) return;
    const w = baseImageData.width, h = baseImageData.height;
    if (startX<0||startY<0||startX>=w||startY>=h) return;
    if (isWallAt(startX, startY)) return;

    pushHistory();

    const {r:fr, g:fg, b:fb} = getRgb(fillHex);
    const stack = [[startX, startY]];
    const visited = new Uint8Array(w*h);
    const idx = (x,y)=> y*w+x;

    while (stack.length) {
      const [x,y] = stack.pop();
      if (x<0||y<0||x>=w||y>=h) continue;

      const v = idx(x,y);
      if (visited[v]) continue;
      visited[v] = 1;

      if (isWallAt(x,y)) continue;

      const p = (y*w + x)*4;
      paintImageData.data[p]   = fr;
      paintImageData.data[p+1] = fg;
      paintImageData.data[p+2] = fb;
      paintImageData.data[p+3] = 255;

      stack.push([x+1,y]); stack.push([x-1,y]); stack.push([x,y+1]); stack.push([x,y-1]);
    }

    composite();
    render();
  }

  function autoFillMany(count=18) {
    if (!baseImageData || !paintImageData) return;
    const w = baseImageData.width, h = baseImageData.height;
    for (let i=0;i<count;i++) {
      const x = Math.floor(Math.random()*w);
      const y = Math.floor(Math.random()*h);
      if (isWallAt(x,y)) continue;
      const r = 120 + Math.floor(Math.random()*135);
      const g = 120 + Math.floor(Math.random()*135);
      const b = 120 + Math.floor(Math.random()*135);
      const hex = '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
      bucketFill(x,y,hex);
    }
  }

  // ---- interactions: tap-fill vs pan ----
  // ê·œì¹™:
  // - í•œ ì†ê°€ë½ "ì§§ê²Œ íƒ­" = ì±„ìš°ê¸°
  // - í•œ ì†ê°€ë½ "ë“œë˜ê·¸" = ì´ë™
  let tapStart = null;

  function onTouchStart(e) {
    if (!baseImageData) return;
    if (e.touches.length === 2) {
      pinchOn = true;
      const a = clientToCanvasCss(e.touches[0].clientX, e.touches[0].clientY);
      const b = clientToCanvasCss(e.touches[1].clientX, e.touches[1].clientY);
      pinchStartDist = Math.hypot(a.x-b.x, a.y-b.y);
      pinchStartScale = scale;
      pinchMid = { x: (a.x+b.x)/2, y: (a.y+b.y)/2 };
      tapStart = null;
      return;
    }

    pinchOn = false;
    const p = clientToCanvasCss(e.touches[0].clientX, e.touches[0].clientY);
    tapStart = { x:p.x, y:p.y, t: Date.now() };
    isPanning = true;
    lastPan = { x:p.x, y:p.y };
  }

  function onTouchMove(e) {
    if (!baseImageData) return;

    if (pinchOn && e.touches.length === 2) {
      const a = clientToCanvasCss(e.touches[0].clientX, e.touches[0].clientY);
      const b = clientToCanvasCss(e.touches[1].clientX, e.touches[1].clientY);
      const dist = Math.hypot(a.x-b.x, a.y-b.y);
      const ratio = dist / pinchStartDist;

      const newScale = clamp(pinchStartScale * ratio, 0.2, 6);

      // í™•ëŒ€ ê¸°ì¤€ì (í•€ì¹˜ ì¤‘ì•™)ì„ ê³ ì •í•˜ë ¤ë©´ offsetì„ ë³´ì •
      // ì´ë¯¸ì§€ ì¢Œí‘œì˜ í•€ì¹˜ ì¤‘ì•™ì´ ê°™ì€ í™”ë©´ ì¢Œí‘œì— ë¨¸ë¬¼ë„ë¡
      const mid = { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
      const imgBefore = cssToImageXY(mid.x, mid.y);
      scale = newScale;
      const imgAfter = cssToImageXY(mid.x, mid.y);

      // imgBeforeì™€ imgAfterê°€ ê°™ì•„ì§€ë„ë¡ offset ì¡°ì •
      offsetX += (imgAfter.x - imgBefore.x) * scale;
      offsetY += (imgAfter.y - imgBefore.y) * scale;

      render();
      return;
    }

    // pan
    if (!isPanning || e.touches.length !== 1) return;
    const p = clientToCanvasCss(e.touches[0].clientX, e.touches[0].clientY);
    const dx = p.x - lastPan.x;
    const dy = p.y - lastPan.y;
    offsetX += dx;
    offsetY += dy;
    lastPan = p;
    render();
  }

  function onTouchEnd(e) {
    if (!baseImageData) return;
    if (pinchOn) {
      pinchOn = false;
      isPanning = false;
      tapStart = null;
      return;
    }

    // tap íŒë‹¨: ì§§ê³  ì´ë™ì´ ê±°ì˜ ì—†ìœ¼ë©´ fill
    if (tapStart) {
      const now = Date.now();
      const dt = now - tapStart.t;
      // ë§ˆì§€ë§‰ ì¢Œí‘œëŠ” touchendì—ì„œ touchesê°€ ë¹„ì–´ìˆì„ ìˆ˜ ìˆìœ¼ë‹ˆ changedTouches ì‚¬ìš©
      const ch = e.changedTouches && e.changedTouches[0];
      if (ch) {
        const p = clientToCanvasCss(ch.clientX, ch.clientY);
        const dist = Math.hypot(p.x - tapStart.x, p.y - tapStart.y);

        if (dt < 250 && dist < 8) {
          const img = cssToImageXY(p.x, p.y);
          bucketFill(img.x, img.y, colorInp.value);
        }
      }
    }

    isPanning = false;
    tapStart = null;
  }

  // desktop click
  view.addEventListener('click', (e) => {
    if (!baseImageData) return;
    const p = clientToCanvasCss(e.clientX, e.clientY);
    const img = cssToImageXY(p.x, p.y);
    bucketFill(img.x, img.y, colorInp.value);
  });

  // touch
  view.addEventListener('touchstart', (e)=>{ e.preventDefault(); onTouchStart(e); }, {passive:false});
  view.addEventListener('touchmove',  (e)=>{ e.preventDefault(); onTouchMove(e); },  {passive:false});
  view.addEventListener('touchend',   (e)=>{ e.preventDefault(); onTouchEnd(e); },   {passive:false});
  view.addEventListener('touchcancel',(e)=>{ e.preventDefault(); onTouchEnd(e); },   {passive:false});

  // ---- buttons ----
  undoBtn.addEventListener('click', () => {
    if (!history.length) return;
    paintImageData = history.pop();
    paintX.putImageData(paintImageData, 0, 0);
    composite();
    render();
  });

  clearBtn.addEventListener('click', () => {
    if (!paintImageData) return;
    pushHistory();
    paintImageData = new ImageData(paintImageData.width, paintImageData.height);
    paintX.putImageData(paintImageData, 0, 0);
    composite();
    render();
  });

  autoBtn.addEventListener('click', () => autoFillMany(22));

  zoomInBtn.addEventListener('click', () => { scale = clamp(scale*1.2, 0.2, 6); render(); });
  zoomOutBtn.addEventListener('click', () => { scale = clamp(scale/1.2, 0.2, 6); render(); });
  zoomResetBtn.addEventListener('click', () => { fitToScreen(); render(); });

  saveBtn.addEventListener('click', () => {
    if (!compC.width) return;
    // í•©ì„±ëœ ê²°ê³¼(compC)ë¥¼ ì €ì¥
    const a = document.createElement('a');
    a.download = 'junho_coloring.png';
    a.href = compC.toDataURL('image/png');
    a.click();
  });

  thresholdInp.addEventListener('input', () => {
    thv.textContent = thresholdInp.value;
    if (!baseImageData) return;
    rebuildLineMask();
    composite();
    render();
  });

  // ---- load image into layers ----
  async function loadFromUrl(url) {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = url;
    await img.decode();

    // ë„ˆë¬´ í° íŒŒì¼ì€ ëª¨ë°”ì¼ ëŠë ¤ì§ˆ ìˆ˜ ìˆìœ¼ë‹ˆ ìµœëŒ€ 1400px ì •ë„
    const maxSide = 1400;
    let w = img.naturalWidth, h = img.naturalHeight;
    const s = Math.min(1, maxSide / Math.max(w,h));
    w = Math.max(1, Math.floor(w*s));
    h = Math.max(1, Math.floor(h*s));

    // set canvas sizes
    [baseC, paintC, lineC, compC].forEach(c => { c.width = w; c.height = h; });
    baseX.clearRect(0,0,w,h);
    baseX.drawImage(img, 0,0,w,h);

    baseImageData = baseX.getImageData(0,0,w,h);
    paintImageData = new ImageData(w,h); // íˆ¬ëª… ì‹œì‘
    history = [];

    rebuildLineMask();

    // paint/line canvasë„ ì´ˆê¸°í™”
    paintX.putImageData(paintImageData, 0, 0);
    lineX.putImageData(lineMaskData, 0, 0);

    composite();

    // view canvas í¬ê¸° ì¬ì¡°ì •(ë¹„ìœ¨ì— ë§ê²Œ)
    resizeViewCanvasToCSS();
    fitToScreen();
    render();
  }

  file.addEventListener('change', async () => {
    const f = file.files && file.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    await loadFromUrl(url);
    URL.revokeObjectURL(url);
  });

  // ---- gallery UI ----
  let currentIndex = 0;

  function buildThumbs() {
    thumbsEl.innerHTML = '';
    PAGES.forEach((p, idx) => {
      const im = document.createElement('img');
      im.src = p.url;
      im.alt = p.title;
      im.title = p.title;
      if (idx === currentIndex) im.classList.add('active');
      im.addEventListener('click', async () => {
        currentIndex = idx;
        [...thumbsEl.querySelectorAll('img')].forEach(x=>x.classList.remove('active'));
        im.classList.add('active');
        await loadFromUrl(PAGES[currentIndex].url);
      });
      thumbsEl.appendChild(im);
    });
  }

  // ---- init ----
  buildThumbs();

  // ì²« í˜ì´ì§€ ìë™ ë¡œë“œ
  // (ê¹ƒí—ˆë¸Œ pagesì—ì„œ íŒŒì¼ ê²½ë¡œë§Œ ë§ìœ¼ë©´ ë°”ë¡œ ëœ¸)
  loadFromUrl(PAGES[currentIndex].url).catch(() => {
    // íŒŒì¼ì´ ì•„ì§ ì—†ì„ ë•Œ ì•ˆë‚´ í™”ë©´
    resizeViewCanvasToCSS();
    const rect = view.getBoundingClientRect();
    vctx.clearRect(0,0,rect.width,rect.height);
    vctx.fillStyle = "#fff";
    vctx.fillRect(0,0,rect.width,rect.height);
    vctx.fillStyle = "#333";
    vctx.font = "16px system-ui, Arial";
    vctx.fillText("pages/page1.png íŒŒì¼ì„ ë¦¬í¬ì§€í† ë¦¬ì— ì˜¬ë ¤ì£¼ì„¸ìš”.", 16, 40);
    vctx.fillText("ê·¸ë¦¬ê³  PAGES ë°°ì—´ì— íŒŒì¼ëª…ì„ ë§ì¶°ì£¼ë©´ ì•± ë‚´ ê°¤ëŸ¬ë¦¬ê°€ ë©ë‹ˆë‹¤.", 16, 64);
  });
})();
</script>
</body>
</html>
